# Nested Array Generator

## Problem Description

Given a multi-dimensional array of integers, implement a generator object that yields integers in the same order as inorder traversal.

A multi-dimensional array is a recursive data structure that contains both integers and other multi-dimensional arrays.

Inorder traversal iterates over each array from left to right, yielding any integers it encounters or applying inorder traversal to any arrays it encounters.

## Examples

### Example 1
```javascript
Input: arr = [[[6]],[1,3],[]]
Output: [6,1,3]

const generator = inorderTraversal(arr);
generator.next().value; // 6
generator.next().value; // 1
generator.next().value; // 3
generator.next().done; // true
```

### Example 2
```javascript
Input: arr = []
Output: []
// There are no integers so the generator doesn't yield anything
```

## Constraints

- `0 <= arr.flat().length <= 10^5`
- `0 <= arr.flat()[i] <= 10^5`
- `maxNestingDepth <= 10^5`

**Note:** Solve this without creating a new flattened version of the array.

## Solutions

### JavaScript Solution

```javascript
/**
 * @param {Array} arr
 * @return {Generator}
 */
var inorderTraversal = function*(arr) {
    for (const element of arr) {
        if (Array.isArray(element)) {
            yield* inorderTraversal(element);
        } else {
            yield element;
        }
    }
};
```

### TypeScript Solution

```typescript
type MultidimensionalArray = (MultidimensionalArray | number)[]

function* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {
    for (const element of arr) {
        if (Array.isArray(element)) {
            yield* inorderTraversal(element);
        } else {
            yield element;
        }
    }
};
```

## Usage

```javascript
// Example usage
const gen = inorderTraversal([1, [2, 3]]);
gen.next().value; // 1
gen.next().value; // 2
gen.next().value; // 3
```

## Algorithm Explanation

The solution uses a recursive generator function with the following logic:

1. **Iterate through elements**: The generator iterates through each element of the input array using a `for...of` loop.

2. **Handle arrays recursively**: When an element is itself an array, it uses `yield*` to delegate to a recursive call of `inorderTraversal`. This ensures all integers from nested arrays are yielded in the correct order before moving to the next element.

3. **Yield integers directly**: When an element is an integer, it yields it immediately.

4. **Generator delegation**: The `yield*` syntax allows one generator to delegate to another generator, maintaining proper traversal order and flow.

## Key Features

- **Efficient traversal**: Processes elements on-demand without pre-computation
- **No extra storage**: Doesn't create a flattened copy of the array
- **Recursive design**: Naturally handles arbitrary nesting depth
- **Generator pattern**: Memory-efficient for large inputs

## Complexity Analysis

- **Time Complexity**: O(n) where n is the total number of integers in the nested structure
- **Space Complexity**: O(d) where d is the maximum nesting depth (due to recursion stack)

## Walkthrough Example

For input `[[[6]],[1,3],[]]`:

1. First element: `[[6]]` (array) → recursive call
   - First element: `[6]` (array) → recursive call  
     - First element: `6` (number) → **yield 6**
   - No more elements in `[6]`
2. Second element: `[1,3]` (array) → recursive call
   - First element: `1` (number) → **yield 1**
   - Second element: `3` (number) → **yield 3**
3. Third element: `[]` (empty array) → no elements to process

**Final output: 6, 1, 3**

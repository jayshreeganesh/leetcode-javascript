# Call Function with Custom Context

## Problem Description

Enhance all functions to have the `callPolyfill` method that allows calling a function with a custom `this` context and additional arguments, without using the built-in `Function.call` method.

The method accepts:
- `obj`: An object that becomes the `this` context for the function
- `...args`: Any number of additional arguments passed to the function

## Solution

### JavaScript Implementation

```javascript
Function.prototype.callPolyfill = function(context, ...args) {
    // Create a unique property name to avoid conflicts
    const uniqueKey = Symbol('temp');
    
    // Assign the function as a method of the context object
    context[uniqueKey] = this;
    
    // Call the function with the context and arguments
    const result = context[uniqueKey](...args);
    
    // Clean up - remove the temporary property
    delete context[uniqueKey];
    
    return result;
}
```

### TypeScript Implementation

```typescript
type JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };

interface Function {
    callPolyfill(context: Record<string, JSONValue>, ...args: JSONValue[]): JSONValue;
}

Function.prototype.callPolyfill = function(context, ...args): JSONValue {
    const uniqueKey = Symbol('temp') as unknown as string;
    
    // Use type assertion to handle the dynamic property assignment
    (context as any)[uniqueKey] = this;
    
    const result = (context as any)[uniqueKey](...args);
    
    delete (context as any)[uniqueKey];
    
    return result;
}
```

## How It Works

1. **Unique Property**: Uses `Symbol('temp')` to create a unique property name that won't conflict with existing properties on the context object.

2. **Context Binding**: Temporarily attaches the function as a method of the context object, so when called, the `this` inside the function refers to the context object.

3. **Argument Passing**: Uses spread syntax `...args` to pass all additional arguments to the function.

4. **Cleanup**: Removes the temporary property to keep the context object unchanged.

## Examples

### Example 1
```javascript
function add(b) {
  return this.a + b;
}

const result = add.callPolyfill({"a": 5}, 7);
console.log(result); // 12
```

### Example 2
```javascript
function tax(price, taxRate) { 
  return `The cost of the ${this.item} is ${price * (1 + taxRate)}`; 
}

const result = tax.callPolyfill({"item": "burger"}, 10, 0.1);
console.log(result); // "The cost of the burger is 11"
```

### Example 3
```javascript
function increment() { 
  this.count++; 
  return this.count; 
}

const result = increment.callPolyfill({count: 1});
console.log(result); // 2
```

## Alternative Implementation

For better safety, you can use `Object.defineProperty`:

```javascript
Function.prototype.callPolyfill = function(context, ...args) {
    const uniqueKey = Symbol('temp');
    
    Object.defineProperty(context, uniqueKey, {
        value: this,
        writable: true,
        enumerable: false,  // Doesn't show up in enumeration
        configurable: true
    });
    
    const result = context[uniqueKey](...args);
    delete context[uniqueKey];
    
    return result;
}
```

## Constraints

- `typeof args[0] == 'object'` and `args[0] != null`
- `1 <= args.length <= 100`
- `2 <= JSON.stringify(args[0]).length <= 105`

## Key Features

- ✅ No use of built-in `Function.call` method
- ✅ Proper `this` context binding
- ✅ Support for multiple arguments
- ✅ Clean implementation without side effects
- ✅ Works with any function and object context

# Snail Traversal

A JavaScript/TypeScript solution that enhances arrays with a `snail` method to transform 1D arrays into 2D arrays following a snail traversal pattern.

## Problem Description

Write code that enhances all arrays such that you can call the `snail(rowsCount, colsCount)` method that transforms a 1D array into a 2D array organized in snail traversal order.

### Snail Traversal Pattern

- Starts at the top-left cell
- First column: traversed from top to bottom
- Second column: traversed from bottom to top
- Third column: traversed from top to bottom
- Continues alternating direction for each subsequent column

### Invalid Input Handling

- Returns empty array if `rowsCount * colsCount !== array.length`
- Returns empty array for any other invalid input

## Solution

### JavaScript Implementation

```javascript
/**
 * @param {number} rowsCount
 * @param {number} colsCount
 * @return {Array<Array<number>>}
 */
Array.prototype.snail = function(rowsCount, colsCount) {
    // Check for invalid input
    if (rowsCount * colsCount !== this.length) {
        return [];
    }
    
    // Initialize empty matrix
    const result = Array(rowsCount).fill().map(() => Array(colsCount).fill(0));
    
    let index = 0;
    
    // Process each column
    for (let col = 0; col < colsCount; col++) {
        if (col % 2 === 0) {
            // Even columns: top to bottom
            for (let row = 0; row < rowsCount; row++) {
                result[row][col] = this[index++];
            }
        } else {
            // Odd columns: bottom to top
            for (let row = rowsCount - 1; row >= 0; row--) {
                result[row][col] = this[index++];
            }
        }
    }
    
    return result;
}
```

### TypeScript Implementation

```typescript
interface Array<T> {
    snail(rowsCount: number, colsCount: number): number[][];
}

Array.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {
    // Check for invalid input
    if (rowsCount * colsCount !== this.length) {
        return [];
    }
    
    // Initialize empty matrix
    const result: number[][] = Array(rowsCount).fill(0).map(() => Array(colsCount).fill(0));
    
    let index = 0;
    
    // Process each column
    for (let col = 0; col < colsCount; col++) {
        if (col % 2 === 0) {
            // Even columns: top to bottom
            for (let row = 0; row < rowsCount; row++) {
                result[row][col] = this[index++];
            }
        } else {
            // Odd columns: bottom to top
            for (let row = rowsCount - 1; row >= 0; row--) {
                result[row][col] = this[index++];
            }
        }
    }
    
    return result;
}
```

## Algorithm Explanation

1. **Input Validation**: Check if the product of rows and columns equals the array length
2. **Matrix Initialization**: Create a 2D array with specified dimensions
3. **Column-wise Processing**:
   - Even columns (0, 2, 4...): Fill from top to bottom
   - Odd columns (1, 3, 5...): Fill from bottom to top
4. **Index Tracking**: Use a single index to traverse the original array sequentially

## Examples

### Example 1
```javascript
const nums = [19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15];
console.log(nums.snail(5, 4));
// Output:
// [
//  [19,17,16,15],
//  [10,1,14,4],
//  [3,2,12,20],
//  [7,5,18,11],
//  [9,8,6,13]
// ]
```

### Example 2
```javascript
const arr = [1, 2, 3, 4];
console.log(arr.snail(1, 4)); // [[1, 2, 3, 4]]
```

### Example 3
```javascript
const nums = [1, 3];
console.log(nums.snail(2, 2)); // [] (invalid input)
```

## Complexity Analysis

- **Time Complexity**: O(n) where n is the length of the array
- **Space Complexity**: O(rowsCount Ã— colsCount) for the output matrix

## Constraints

- `0 <= nums.length <= 250`
- `1 <= nums[i] <= 1000`
- `1 <= rowsCount <= 250`
- `1 <= colsCount <= 250`

## Usage

```javascript
// After adding the prototype method
const myArray = [1, 2, 3, 4, 5, 6];
const result = myArray.snail(2, 3);
console.log(result);
// [[1, 6, 5],
//  [2, 3, 4]]
```

The solution efficiently transforms 1D arrays into 2D arrays following the specified snail traversal pattern while handling edge cases appropriately.

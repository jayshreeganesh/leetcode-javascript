# Cancellable Function Design

A TypeScript/JavaScript solution for creating cancellable generator functions that yield promises. This implementation allows you to start long-running asynchronous tasks and cancel them before completion if needed.

## Problem Description

Sometimes you have a long running task, and you may wish to cancel it before it completes. The goal is to write a function `cancellable` that accepts a generator object and returns an array of two values: a cancel function and a promise.

## Requirements

1. The generator function will only yield promises
2. Pass values resolved by promises back to the generator
3. If a promise rejects, throw that error back to the generator
4. If the cancel callback is called before the generator is done:
   - Throw "Cancelled" (string) error to the generator
   - If the error is caught, resolve with the next yielded/returned value
   - Otherwise, reject with the thrown error
5. When the generator completes:
   - Resolve with the returned value if successful
   - Reject with the error if the generator throws

## Installation

No additional dependencies required. This works with standard TypeScript and JavaScript environments.

## Usage

### TypeScript

```typescript
function* tasks() {
  const val = yield new Promise(resolve => resolve(2 + 2));
  yield new Promise(resolve => setTimeout(resolve, 100));
  return val + 1;
}

const [cancel, promise] = cancellable(tasks());
setTimeout(cancel, 50);
promise.catch(console.log); // logs "Cancelled" at t=50ms
```

### JavaScript

```javascript
function* tasks() {
  const val = yield new Promise(resolve => resolve(2 + 2));
  yield new Promise(resolve => setTimeout(resolve, 100));
  return val + 1;
}

const [cancel, promise] = cancellable(tasks());
setTimeout(cancel, 50);
promise.catch(console.log); // logs "Cancelled" at t=50ms
```

## API

### `cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>]`

**Parameters:**
- `generator`: A generator function that yields promises

**Returns:**
- A tuple containing:
  - `cancel`: Function to cancel the generator execution
  - `promise`: Promise that resolves with the generator's return value or rejects with an error

## Implementation

### TypeScript Version

```typescript
function cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {
    let cancelled = false;
    
    const cancel = () => {
        cancelled = true;
    };
    
    const promise = new Promise<T>((resolve, reject) => {
        const handle = (value?: any, isError = false): void => {
            if (cancelled) {
                try {
                    const result = generator.throw("Cancelled");
                    resolve(result.value as T);
                } catch (err) {
                    reject(err);
                }
                return;
            }
            
            try {
                const result = isError ? 
                    generator.throw(value) : 
                    generator.next(value);
                
                if (result.done) {
                    resolve(result.value as T);
                    return;
                }
                
                // Handle the yielded promise with type assertion
                (result.value as Promise<any>).then(
                    (resolvedValue) => handle(resolvedValue),
                    (rejectedValue) => handle(rejectedValue, true)
                );
            } catch (err) {
                reject(err);
            }
        };
        
        // Start the generator execution
        handle();
    });
    
    return [cancel, promise];
}
```

### JavaScript Version

```javascript
var cancellable = function(generator) {
    let cancelled = false;
    
    const cancel = () => {
        cancelled = true;
    };
    
    const promise = new Promise((resolve, reject) => {
        const handle = (value, isError = false) => {
            if (cancelled) {
                try {
                    const result = generator.throw("Cancelled");
                    resolve(result.value);
                } catch (err) {
                    reject(err);
                }
                return;
            }
            
            try {
                const result = isError ? 
                    generator.throw(value) : 
                    generator.next(value);
                
                if (result.done) {
                    resolve(result.value);
                    return;
                }
                
                // Handle the yielded promise
                result.value.then(
                    (resolvedValue) => handle(resolvedValue),
                    (rejectedValue) => handle(rejectedValue, true)
                );
            } catch (err) {
                reject(err);
            }
        };
        
        // Start the generator execution
        handle();
    });
    
    return [cancel, promise];
};
```

## Examples

### Example 1: Immediate Completion

```typescript
function* immediateGenerator() { 
  return 42; 
}

const [cancel, promise] = cancellable(immediateGenerator());
promise.then(console.log); // resolves 42 immediately
```

**Output:** `{"resolved": 42}`

### Example 2: Generator Throws Error

```typescript
function* errorGenerator() { 
  const msg = yield new Promise(res => res("Hello")); 
  throw `Error: ${msg}`; 
}

const [cancel, promise] = cancellable(errorGenerator());
promise.catch(console.log); // rejects with "Error: Hello"
```

**Output:** `{"rejected": "Error: Hello"}`

### Example 3: Cancellation Before Completion

```typescript
function* timeoutGenerator() { 
  yield new Promise(res => setTimeout(res, 200)); 
  return "Success"; 
}

const [cancel, promise] = cancellable(timeoutGenerator());
setTimeout(cancel, 50);
promise.catch(console.log); // rejects with "Cancelled"
```

**Output:** `{"rejected": "Cancelled"}`

### Example 4: Normal Execution

```typescript
function* normalGenerator() { 
  let result = 0; 
  yield new Promise(res => setTimeout(res, 100));
  result += yield new Promise(res => res(1)); 
  yield new Promise(res => setTimeout(res, 100)); 
  result += yield new Promise(res => res(1)); 
  return result;
}

const [cancel, promise] = cancellable(normalGenerator());
promise.then(console.log); // resolves 2 after 200ms
```

**Output:** `{"resolved": 2}`

### Example 5: Caught Cancellation

```typescript
function* caughtCancellationGenerator() { 
  let result = 0; 
  try { 
    yield new Promise(res => setTimeout(res, 100)); 
    result += yield new Promise(res => res(1)); 
    yield new Promise(res => setTimeout(res, 100)); 
    result += yield new Promise(res => res(1)); 
  } catch(e) { 
    return result; 
  } 
  return result; 
}

const [cancel, promise] = cancellable(caughtCancellationGenerator());
setTimeout(cancel, 150);
promise.then(console.log); // resolves 1 (current result when cancelled)
```

**Output:** `{"resolved": 1}`

### Example 6: Caught Promise Rejection

```typescript
function* caughtRejectionGenerator() { 
  try { 
    yield new Promise((resolve, reject) => reject("Promise Rejected")); 
  } catch(e) { 
    let a = yield new Promise(resolve => resolve(2));
    let b = yield new Promise(resolve => resolve(2)); 
    return a + b; 
  }; 
}

const [cancel, promise] = cancellable(caughtRejectionGenerator());
promise.then(console.log); // resolves 4
```

**Output:** `{"resolved": 4}`

## How It Works

### Algorithm

1. **Initialization**: Create a cancellation flag and return a cancel function + promise
2. **Recursive Handling**: Use a recursive `handle` function to process generator steps
3. **Promise Resolution**: For each yielded promise:
   - If resolved: pass value back to generator via `generator.next(value)`
   - If rejected: throw error back to generator via `generator.throw(error)`
4. **Cancellation Check**: Before each step, check if cancelled and throw "Cancelled" if needed
5. **Completion**: When generator is done (`result.done`), resolve the main promise

### Error Handling Flow

```
Generator yields promise → 
  If cancelled? → throw "Cancelled" to generator
  Else → wait for promise → 
    If promise resolves → generator.next(resolvedValue)
    If promise rejects → generator.throw(rejectedError)
```

## TypeScript Specific Notes

- **Type Assertions**: Added `as T` and `as Promise<any>` to handle TypeScript's strict typing
- **Generator Types**: Properly typed the generator parameter with `Generator<Promise<any>, T, unknown>`
- **Return Type**: Ensured the function returns the correct tuple type `[() => void, Promise<T>]`

## Key Features

1. **Recursive Promise Handling**: Uses a recursive approach to handle the chain of promises yielded by the generator
2. **Cancellation Propagation**: Immediately checks for cancellation before processing each generator step
3. **Error Isolation**: Each generator step is wrapped in try-catch to handle both promise rejections and generator errors
4. **Two-way Communication**: Uses `generator.next()` for values and `generator.throw()` for errors
5. **Completion Detection**: Checks `result.done` to determine when the generator has finished
6. **Type Safety**: Proper TypeScript typing with necessary type assertions

## Constraints

- `cancelledAt == null or 0 <= cancelledAt <= 1000`
- `generatorFunction` returns a generator object
- Generator only yields promises

## Use Cases

- Long-running asynchronous operations
- API calls that may need to be cancelled
- File uploads/downloads
- Complex multi-step async workflows
- Any scenario where you need fine-grained control over async task execution

This implementation provides a robust, type-safe solution for managing cancellable asynchronous operations using generators, enabling fine-grained control over long-running tasks with proper error handling and cancellation support.

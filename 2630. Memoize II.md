# Memoize II

A memoization implementation that caches function results based on input arguments, where inputs are considered identical only if they are strictly equal (`===`).

## Problem Description

Given a function `fn`, return a memoized version of that function. A memoized function will never be called twice with the same inputs - instead it returns a cached value.

**Key Constraint**: Inputs are considered identical only if they are `===` to each other. This means objects with the same content but different references are treated as different inputs.

## Examples

### Example 1: Primitive Values
```javascript
const fn = function(a, b) { return a + b; };
const memoized = memoize(fn);

memoized(2, 2); // 4 (calls fn)
memoized(2, 2); // 4 (cache hit)
memoized(1, 2); // 3 (calls fn)
// Total calls: 2
```

### Example 2: Different Object References
```javascript
const fn = function(a, b) { return ({...a, ...b}); };
const memoized = memoize(fn);

memoized({}, {}); // {} (calls fn)
memoized({}, {}); // {} (calls fn again - different references)
memoized({}, {}); // {} (calls fn again - different references)
// Total calls: 3
```

### Example 3: Same Object References
```javascript
const fn = function(a, b) { return ({...a, ...b}); };
const memoized = memoize(fn);
const o = {};

memoized(o, o); // {} (calls fn)
memoized(o, o); // {} (cache hit)
memoized(o, o); // {} (cache hit)
// Total calls: 1
```

## Solution

### Approach

The solution uses a nested `Map` structure to cache results:

1. **Nested Cache**: Each level of the cache corresponds to an argument position
2. **Reference-based Keys**: Since `Map` uses `===` for key comparison, objects with different references are automatically treated as different
3. **Result Storage**: At the deepest level, the computed result is stored

### Implementation

#### JavaScript
```javascript
function memoize(fn) {
    const cache = new Map();
    
    return function(...args) {
        let currentCache = cache;
        
        for (const arg of args) {
            if (!currentCache.has(arg)) {
                currentCache.set(arg, new Map());
            }
            currentCache = currentCache.get(arg);
        }
        
        if (currentCache.has('result')) {
            return currentCache.get('result');
        }
        
        const result = fn.apply(this, args);
        currentCache.set('result', result);
        return result;
    };
}
```

#### TypeScript
```typescript
type Fn = (...params: any) => any

function memoize(fn: Fn): Fn {
    const cache = new Map();
    
    return function(...args: any[]) {
        let currentCache = cache;
        
        for (const arg of args) {
            if (!currentCache.has(arg)) {
                currentCache.set(arg, new Map());
            }
            currentCache = currentCache.get(arg);
        }
        
        if (currentCache.has('result')) {
            return currentCache.get('result');
        }
        
        const result = fn.apply(this, args);
        currentCache.set('result', result);
        return result;
    };
}
```

## How It Works

1. **Argument Navigation**: For each argument, navigate deeper into the cache structure
2. **Cache Creation**: Create new Maps as needed for unseen argument combinations
3. **Result Lookup**: Check if result exists at the final cache level
4. **Result Computation**: Compute and cache the result if not found

## Complexity Analysis

- **Time Complexity**: O(n) where n is the number of arguments
- **Space Complexity**: Depends on the number of unique argument combinations

## Features

- ✅ Handles primitive values (numbers, strings, etc.)
- ✅ Handles object references correctly
- ✅ Supports any number of arguments
- ✅ Supports any type of arguments
- ✅ Maintains `this` context

## Usage

```javascript
let callCount = 0;
const memoizedFn = memoize(function(a, b) {
    callCount += 1;
    return a + b;
});

# Memoize II - Solution Without Spread Operator

Here are the implementations without using the spread operator (`...args`):

## JavaScript Solution

```javascript
/**
 * @param {Function} fn
 * @return {Function}
 */
function memoize(fn) {
    const cache = new Map();
    
    return function() {
        let currentCache = cache;
        const argsLength = arguments.length;
        
        // Navigate through the cache using the arguments as keys
        for (let i = 0; i < argsLength; i++) {
            const arg = arguments[i];
            if (!currentCache.has(arg)) {
                currentCache.set(arg, new Map());
            }
            currentCache = currentCache.get(arg);
        }
        
        // If we have a cached result at this level, return it
        if (currentCache.has('result')) {
            return currentCache.get('result');
        }
        
        // Otherwise, compute the result and cache it
        const result = fn.apply(this, arguments);
        currentCache.set('result', result);
        return result;
    };
}
```

## TypeScript Solution

```typescript
type Fn = (...params: any) => any

function memoize(fn: Fn): Fn {
    const cache = new Map();
    
    return function() {
        let currentCache = cache;
        const args = arguments;
        const argsLength = args.length;
        
        // Navigate through the cache using the arguments as keys
        for (let i = 0; i < argsLength; i++) {
            const arg = args[i];
            if (!currentCache.has(arg)) {
                currentCache.set(arg, new Map());
            }
            currentCache = currentCache.get(arg);
        }
        
        // If we have a cached result at this level, return it
        if (currentCache.has('result')) {
            return currentCache.get('result');
        }
        
        // Otherwise, compute the result and cache it
        const result = fn.apply(this, arguments);
        currentCache.set('result', result);
        return result;
    };
}
```

## Alternative JavaScript Solution (Using Array.from)

```javascript
/**
 * @param {Function} fn
 * @return {Function}
 */
function memoize(fn) {
    const cache = new Map();
    
    return function() {
        let currentCache = cache;
        const args = Array.from(arguments);
        
        // Navigate through the cache using the arguments as keys
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            if (!currentCache.has(arg)) {
                currentCache.set(arg, new Map());
            }
            currentCache = currentCache.get(arg);
        }
        
        // If we have a cached result at this level, return it
        if (currentCache.has('result')) {
            return currentCache.get('result');
        }
        
        // Otherwise, compute the result and cache it
        const result = fn.apply(this, args);
        currentCache.set('result', result);
        return result;
    };
}
```

## Alternative TypeScript Solution (Using Array.from)

```typescript
type Fn = (...params: any) => any

function memoize(fn: Fn): Fn {
    const cache = new Map();
    
    return function() {
        let currentCache = cache;
        const args = Array.from(arguments);
        
        // Navigate through the cache using the arguments as keys
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            if (!currentCache.has(arg)) {
                currentCache.set(arg, new Map());
            }
            currentCache = currentCache.get(arg);
        }
        
        // If we have a cached result at this level, return it
        if (currentCache.has('result')) {
            return currentCache.get('result');
        }
        
        // Otherwise, compute the result and cache it
        const result = fn.apply(this, args);
        currentCache.set('result', result);
        return result;
    };
}
```

## Key Changes Made

1. **Removed `...args`** parameter
2. **Using `arguments` object** to access all passed arguments
3. **Using `arguments.length`** to iterate through parameters
4. **Using `fn.apply(this, arguments)`** to call the original function with all arguments

## How It Works

The solution still maintains the same core logic:

1. **Nested Map Structure**: Each argument navigates deeper into the cache
2. **Reference-based Comparison**: Uses `===` comparison via Map keys
3. **Result Caching**: Stores computed results to avoid redundant calculations

## Usage Example

```javascript
let callCount = 0;
const memoizedFn = memoize(function(a, b) {
    callCount += 1;
    return a + b;
});

memoizedFn(2, 3); // 5 (calls fn)
memoizedFn(2, 3); // 5 (cache hit)
memoizedFn(1, 2); // 3 (calls fn)
console.log(callCount); // 2
```

All implementations work identically to the spread operator version, just using the traditional `arguments` object to handle variable numbers of parameters.

memoizedFn(2, 3); // 5
memoizedFn(2, 3); // 5 (cache hit)
console.log(callCount); // 1
```
